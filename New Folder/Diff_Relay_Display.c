/***********************************************************************/
/*                                                                     */
/*  FILE        :Diff_Relay_Display.c                                  */
/*  DATE        :XXX,XX-XX-XX		                               */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :dsPIC33F                                              */
/*                                                                     */
/*  This file is generated by MPLAB (Ver.8.46).                        */
/*                                                                     */
/***********************************************************************/

#include <p33FJ256GP710.h> 
#include "define.h"
#include "UART_Comm.h"
#include "PC_Comm.h"
#include "LCD_7981.h"
#include "discon.h"
#include "test.h"
#include "math.h"
#include "GUI.h"
#include "PC_Comm.h"

//25Sep14 Baud rate changed to 9600!!!!!!!!! 
//26Sep14 Added BF_MODE, added BF2 window
//19Nov14 Cumm Brk Curr in Ver A, RmtTrp in fault details

/***************************************************************************************/
//=================================== Select Configuration Bits =======================
// External Oscillator 
_FOSCSEL(FNOSC_FRC);
_FOSC(FCKSM_CSECME & OSCIOFNC_OFF & POSCMD_XT);

_FWDT(FWDTEN_ON & WINDIS_OFF & WDTPRE_PR32 & WDTPOST_PS8192); //EdTR watchdog // Watchdog Timer Enabled and kept of 0.512s
_FGS(GCP_ON);

//EdTR watchdog _FWDT(FWDTEN_OFF);
//_FGS(GCP_OFF);
//=====================================================================================

//EdTR RST_TMS and TMS_PRG_HOLD commented
char RST_TMS12345;

#define AUTHN	1

#define MIN_DIS_CURR	0.04
#define MIN_DIS_VOLT	1

uBYTE COMMAND_TYPE;

extern volatile uBYTE key_code;
extern char rcv;

uBYTE Refresh_Cnt;
uBYTE Cmnd_Swap = 0;
/***************************************************************************************/
void All_Read_On_Reset(void);

//***************************************************************************************
extern void Init_Hardware(void);
extern void Get_Key(void);
extern void Send_MC_Data_PC(void);
extern void DispAll(void);
extern void Start_Screen(void);
extern void Boot_main(void);
extern void Show_Programming_Device(void);
//***************************************************************************************

int main(void)
{
    PLLFBD = 0x000E;
    CLKDIV = 0x0000;
    __builtin_write_OSCCONH(0x33);
    __builtin_write_OSCCONL(0x01);
    while ((OSCCON & 0x0001) == 0x0001);
    while (!OSCCONbits.LOCK);
    // 16 MIPS

    Init_Hardware();
    Get_Display_Para();

    InitBL = 0;

    SetTextMode();
    GLCD_clrscr_TEXT();

  
    while (1)
    {
        ClrWdt();
        Get_Key();



        if ((PC_Comm.QueryReceived) && (!SCR_FLAG.Read_On_Reset))
        {
#if AUTHN
            if (!PC_Comm.MC_Command_Busy)
#endif
            {
                if (PC_Comm_Rx_Buff[CMD1] == CMD_BL_PRGM)
                {
                    Send_Data_PC(); //EdTR added
                    PC_Comm.PC_Command_Busy = 0;
                }
                else
                {
                    Send_PC_Data_MC();
                    PC_Comm.PC_Command_Busy = 1;
                }
                PC_Comm.QueryReceived = 0;
                PCflag_Timeout=0; //Added 2Aug14 MC_TO_PC responce timeout


                //			UART_Fail_Count++;
            }

        }

        if ((!UART2_FLAG.CommandDelay) && (!UART2_FLAG.ResponseReceived) && (!KEYBRD_FLAG.BYTE.EditMode) && (!PC_Comm.PC_Command_Busy))
        {
            Send_DisCommand(); //send command to slave

        }

        if (SCR_FLAG.Read_On_Reset)
        {
            All_Read_On_Reset();
            //			UART_Fail_Count++;
        }


      

        if (UART_Fail_Count <= 4)
        {
            DispAll();
        }
      

        //Delay();Delay();Delay();Delay();Delay(); //EdTR added
    }
}

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//EdTR added

void __attribute__((__interrupt__, auto_psv)) _MathError(void)//ISR
{
    if (INTCON1bits.DIV0ERR)
        INTCON1bits.MATHERR = 0;
    else
        asm("RESET");
}

/***********************************************************************************
Function Name : Analyze_Received_Data()
Description	  :	process received command
Parameters	  : received command
Return value  : none
Word Data received as MSB byte 1st, LSB 2nd.
 ***********************************************************************************/
void Analyze_Received_Data(void)
{
    Rx_Data_LEN = UART2_Rx_Buff[CMD2];
    if ((UART2_Rx_Buff[Rx_Data_LEN + 4]) != '!')
    {
        UART_Fail_Count = 0;
        return;
    }

    if (UART2_Rx_Buff[CMD1] == ACK_CMND)
    {
        Check_ACK_Response();
        return;
    }

    if (UART2_Rx_Buff[CMD1] == FAULT_DISP)
    {
        FAULT_FLAG = 1;
        return;
    }


    /*	if(UART2_Rx_Buff[CMD1]==CMND_F3)
            {
                    if((UART2_Rx_Buff[CMD2]==1)&&(UART2_Rx_Buff[CMD3]==0))
                    {
                            Authenticate();
                            POWER_ON_WRITE();
                    }
                    return;
            }*/

    if (UART2_Rx_Buff[CMD1] == ERR_CMND)
    {
        Check_Error_Response();
    }
    else
    {
        if (UART2_Rx_Buff[Rx_Data_LEN + 3] != Calculate_Checksum(UART2_Rx_Buff, Rx_Data_LEN + 3))
        {
            UART2_SendCommand(Command_Sent); //checksum error
        }

        else
        {
            if(UART2_Rx_Buff[CMD1] != Command_Sent)
			Command_Sent = UART2_Rx_Buff[CMD1];

            if (Command_Sent != CMD_RD_FAULT)
                Copy_String(UART2_Rx_Buff, Rx_SetFrame.U2_Rx_SetData, (UART2_Rx_Count - 2));

            switch (Command_Sent)
            {
            case RD_SRNO:
                Get_SRNO();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_HW_CONF:
                Get_HW_CONF();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_ALL_CONF:
                Get_ALL_CONF();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;

            case RD_ERROR:
                Get_Error_Val();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;

            case CMD_RD_CURRENT:
                Get_Current_Values();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_SEC_VOLT:
                Get_Voltage_Val();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_PHASE_ANGLE:
                Get_Angle_Val();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case CMD_RD_RMS1:
            case CMD_RD_RMS2:
            case CMD_RD_RMS3:
                Get_RMS_Values();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case CMD_RD_FAULT:
                Get_Fault_Val();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case CMD_RD_EVENT:
				Get_Event_Data();
				SCR_FLAG.UpdtScr_OnRcv = 1;
			break;

            case RD_BD_SET:
                Get_BD_Setting();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_BDHS_SET:
                Get_BDHS_Setting();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_REF_SET:
                Get_REF_Setting();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_I2OC_SET:
                Get_I2OC_Setting();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_OF_SET: //14May14 UF OF
                Get_OF_Setting();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_COMM_SET:
                Get_COMM_Setting();
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;
            case RD_XCBR_SET: //13May14 XCBR
                Get_XCBR_Setting();
                break;
            case RD_VER_IO_SET:
                Get_VER_IO_Setting();
                break;
            case RD_IP_SET:
                Get_IP_Setting();
                break;
			
			case RD_DI_DBNC_SET:
				Get_DI_DBNC_Setting();
				update_screen = 1;
			break;

            case CALIB_CMND:
                Get_Cal_Sts();
                Calib_Flag.Calib_Cmplt = 1;
                Calib_Flag.Cal_Running = 0;
                SCR_FLAG.UpdtScr_OnRcv = 1;
                break;


            default:
                break;
            }
			
			
        }
    }
    //UART2_FLAG.ResponseReceived=0;
}


//************************************************************************************
//************************************************************************************

void Get_SWDI_Setting(uBYTE ID)
{
    uBYTE i, j, CNT;
    uWORD LedVal;

    if (ID == 0)
        SWDI_SUB_COMD = Rx_SetFrame.SWDI_RxSet.SubCommand;
    if (ID == 1)
        SWDI_SUB_COMD = Rx_SetFrame.LED_RxSet.SubCommand;

    switch (SWDI_SUB_COMD)
    {
    case 0:
        CNT = BD_SWDI_CNT;
        SWDI_RD_Start = BD_SWDI_OFF;
        break;
    case 1:
        CNT = REF_SWDI_CNT;
        SWDI_RD_Start = REF_SWDI_OFF;
        break;
    case 2:
        CNT = THRM_SWDI_CNT;
        SWDI_RD_Start = THRM_SWDI_OFF;
        break;
    case 3:
        CNT = OFLX_SWDI_CNT;
        SWDI_RD_Start = OFLX_SWDI_OFF;
        break;
    case 4:
        CNT = PF_SWDI_CNT;
        SWDI_RD_Start = PF_SWDI_OFF;
        break;
    case 5:
        CNT = PFHS_SWDI_CNT;
        SWDI_RD_Start = PFHS_SWDI_OFF;
        break;
    case 6:
        CNT = Ig_SWDI_CNT;
        SWDI_RD_Start = Ig_SWDI_OFF;
        break;
    case 7:
        CNT = IgHS_SWDI_CNT;
        SWDI_RD_Start = IgHS_SWDI_OFF;
        break;
    case 8:
        CNT = Io_SWDI_CNT;
        SWDI_RD_Start = Io_SWDI_OFF;
        break;
    case 9:
        CNT = IoHS_SWDI_CNT;
        SWDI_RD_Start = IoHS_SWDI_OFF;
        break;
    case 10:
        CNT = I2OC_SWDI_CNT;
        SWDI_RD_Start = I2OC_SWDI_OFF;
        break;
    case 11:
        CNT = I2HS_SWDI_CNT;
        SWDI_RD_Start = I2HS_SWDI_OFF;
        break;
    case 12:
        CNT = UC_SWDI_CNT;
        SWDI_RD_Start = UC_SWDI_OFF;
        break;
    case 13:
        CNT = OV_SWDI_CNT;
        SWDI_RD_Start = OV_SWDI_OFF;
        break;
    case 14:
        CNT = UV_SWDI_CNT;
        SWDI_RD_Start = UV_SWDI_OFF;
        break;
    case 15:
        CNT = NDR_SWDI_CNT;
        SWDI_RD_Start = NDR_SWDI_OFF;
        break;
    case 16:
        CNT = OF_SWDI_CNT;
        SWDI_RD_Start = OF_SWDI_OFF;
        break;
    case 17:
        CNT = UF_SWDI_CNT;
        SWDI_RD_Start = UF_SWDI_OFF;
        break;
    case 18:
        CNT = SUPR_SWDI_CNT;
        SWDI_RD_Start = SUPR_SWDI_OFF;
        break;
    case 19:
        CNT = BEF_SWDI_CNT;
        SWDI_RD_Start = BEF_SWDI_OFF;
        break;
    case 20:
        CNT = ARCL_SWDI_CNT;
        SWDI_RD_Start = ARCL_SWDI_OFF;
        break;
    case 21:
        CNT = UPWR_SWDI_CNT;
        SWDI_RD_Start = UPWR_SWDI_OFF;
        break;
    case 22:
        CNT = OPWR_SWDI_CNT;
        SWDI_RD_Start = OPWR_SWDI_OFF;
        break;

    default:
        return;
        break;
    }

    if (ID == 0)
    {
/*#if VERSION_A		
		for(i=0; i<CNT; i++)	
		{	
			LedVal = (Rx_SetFrame.SWDI_RxSet.DO_RxSet[i]>>2) & 0x3FC0;
			SWDI[SWDI_RD_Start+i].RELAY_DO = (Rx_SetFrame.SWDI_RxSet.DO_RxSet[i] & 0x003F) | LedVal;
		}
#endif*/

#if VERSION_I		//For I model DSP side: HW is Drawout relay, SW is Non-Drawout relay
		for(i=0; i<CNT; i++)
			SWDI[SWDI_RD_Start+i].RELAY_DO = Rx_SetFrame.SWDI_RxSet.DO_RxSet[i];
#endif	

#if VERSION_B
		for(i=0; i<CNT; i++)
			SWDI[SWDI_RD_Start+i].RELAY_DO = Rx_SetFrame.SWDI_RxSet.DO_RxSet[i];
#endif
        
    }
    if (ID == 1)
    {
        for (i = 0; i < CNT; i++)
        {
            LedVal = Rx_SetFrame.LED_RxSet.LED_RCV[i];
            if ((LedVal == 0) || (LedVal < 0x0010))
            {
                SWDI_LED[SWDI_RD_Start + i] = MAX_LED;
            }
            else
            {
                for (j = 0; j < MAX_LED; j++)
                {
                    if (LedVal & 0x0001)
                    {
                        SWDI_LED[SWDI_RD_Start + i] = j;
                        break;
                    }
                    LedVal = LedVal >> 1;
                    LedVal = LedVal & 0x7FFF;
                }
            }
        }
    }

}
